#!/usr/bin/env python3

import abc
import importlib
import os
import shlex
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Sequence, Set, Union

DRY_RUN = False
REPO_BASE = Path(__file__).resolve().parent
XDG_CONFIG_DIR = Path.home() / '.config'
HOME = Path.home()


def run(
    cmd: Union[str, Sequence[Union[Path, str]]],
    capture=False,
) -> subprocess.CompletedProcess:
    resolved_cmd = shlex.split(cmd) if isinstance(cmd, str) else cmd
    return subprocess.run(
        resolved_cmd,
        stdout=subprocess.PIPE if capture else None,
        cwd=REPO_BASE,
    )


class ConfiguredPackage:
    deps: Set["ConfiguredPackage"] = {}
    system_packages: Set["SystemPackage"] = {}
    files: Sequence["Config"] = {}

    def __init__(self, deps=set(), system_packages=set(), files=[], after=None):
        self.deps = deps
        self.system_packages = system_packages
        self.files = files
        self.after = after


class SystemPackage(abc.ABC):
    pass


class Pacman(SystemPackage):
    name: str = ""

    def __init__(self, name: str):
        self.name = name

    @staticmethod
    def list_installed() -> Set[str]:
        if not hasattr(Pacman, "_installed"):
            Pacman._installed = {
                o.split(" ")[0] for o in run("pacman -Q", capture=True).stdout.decode("utf-8").split()
            }
        return Pacman._installed

    @staticmethod
    def install(*pkgs: "Pacman") -> None:
        wanted = {pkg.name for pkg in pkgs}
        installed = Pacman.list_installed()

        to_be_installed = wanted - installed
        if not to_be_installed:
            # everything is already installed
            return

        if DRY_RUN:
            print(f"WOULD INSTALL: {', '.join(to_be_installed)}")
        else:
            run(["sudo", "pacman", "-Syu", "--needed", "-y"] + list(to_be_installed))


class Aur(SystemPackage):
    def __init__(self, *definitions):
        self.packages = definitions

    def install(self):
        to_be_installed = []
        for pkg in self.packages:
            local_pkg = Path(pkg)
            if local_pkg.exists():
                pkgbuild = local_pkg if local_pkg.is_file() else local_pkg / "PKGBUILD"
                for line in pkgbuild.read_text().split("\n"):
                    if line.startswith("pkgname="):
                        pkgname = line[8:].strip("'\"")
                        if pkgname not in Pacman.list_installed():
                            to_be_installed.append(pkg)
                        break
            elif pkg not in Pacman.list_installed():
                to_be_installed.append(pkg)
            else:
                print(pkg)

        if not len(to_be_installed):
            return
        elif DRY_RUN:
            print(f"$ aur install {' '.join(to_be_installed)}")
        else:
            run(["aur", "install"] + to_be_installed)


class PythonVenv(SystemPackage):
    PATH = HOME / ".local"

    def __init__(self, name: str, *pkgs: str):
        self.name = name
        self.requirements = set(pkgs)

    def install(self):
        if not (self.PATH / self.name).exists():
            if DRY_RUN:
                if not self.PATH.exists():
                    print(f"$ mkdir -p {self.PATH}")
                print(f"$ python -m venv {self.PATH / self.name}")
            else:
                if not self.PATH.exists():
                    self.PATH.mkdir(parents=True)
                run(f"python -m venv {self.PATH / self.name}")

        installed_requirements = {req.split("=")[0] for req in run(
            [self.PATH / self.name / "bin/python", "-m", "pip", "freeze"],
            capture=True,
        ).stdout.decode("utf-8").split()} if (self.PATH / self.name / "bin/python").exists() else set()
        to_be_installed = self.requirements - installed_requirements
        if to_be_installed:
            if DRY_RUN:
                print(f"$ {self.PATH / self.name}/bin/python -m pip install {' '.join(self.requirements)}")
            else:
                run(
                    [self.PATH / self.name / "bin/python", "-m", "pip", "install"]
                    + list(self.requirements)
                )


class Config:
    src: Path
    dst: Path

    @staticmethod
    def _convert_loc(a: Union[Path, str]) -> Path:
        if not isinstance(a, Path):
            a = Path(a)

        if a.is_absolute():
            return a

        return REPO_BASE / a

    def __init__(self, src: Union[Path, str], dst: Union[Path, str]):
        self.src = self._convert_loc(src)
        self.dst = self._convert_loc(dst)

    def create(self, overwrite: bool = False) -> None:
        if not self.src.exists():
            # This probably means a typo somewhere
            raise FileNotFoundError(self.src)

        if self.dst.exists():
            if self.dst.resolve() == self.src:
                # already the right symlink
                return

            if not overwrite:
                return
            else:
                self.dst.unlink()

        if not self.dst.parent.exists():
            if DRY_RUN:
                print(f"$ mkdir -p {self.dst.parent}")
            else:
                self.dst.parent.mkdir(parents=True)

        if DRY_RUN:
            print(f"$ ln -s {self.src} {self.dst}")
        else:
            self.dst.symlink_to(self.src)


class Perms:
    target: Path
    perms: int
    MASK=0o777

    def __init__(self, target: Path, perms: int):
        self.target = target
        self.perms = perms

    def create(self) -> None:
        if not self.target.exists():
            if DRY_RUN:
                print(f"$ mkdir -p {self.target}")
            else:
                self.target.mkdir(parents=True)

        current = self.target.stat().st_mode & Perms.MASK
        if current == self.perms:
            return

        if DRY_RUN:
            print(f"$ chmod {self.perms} {self.target}")
        else:
            self.target.chmod(self.perms)


def ensure_service(service, user=False):
    systemctl = "systemctl --user" if user else "systemctl"
    if run(f"{systemctl} status {service}", capture=True).returncode == 0:
        return

    if DRY_RUN and user:
        print(f"$ systemctl --user enable --now {service}")
    elif DRY_RUN:
        print(f"$ sudo systemctl enable --now {service}")
    elif user:
        run(f"systemctl --user enable --now {service}")
    else:
        run(f"sudo systemctl enable --now {service}")


def add_group(group):
    user = os.environ["USER"]
    groups = run(f"groups {user}", capture=True).stdout.decode("utf-8").split()
    if group in groups:
        return

    if DRY_RUN:
        print(f"$ sudo usermod -aG {group} {user}")
        print(f"$ newgrp {group}")
    else:
        run(f"sudo usermod -aG {group} {user}")
        run(f"newgrp {group}")


_pkgs = {}
_pkgs["sxhkd"] =  ConfiguredPackage(
    system_packages={Pacman("sxhkd")},
    files=[
        Config("sxhkd/sxhkdrc", XDG_CONFIG_DIR / "sxhkd/sxhkdrc"),
    ],
)
_pkgs["bspwm"] = ConfiguredPackage(
    deps={_pkgs["sxhkd"]},
    system_packages={
        Pacman("bspwm"), Pacman("xorg-xinit"), Pacman("xorg-server")
    },
    files=[
        Config("bspwm/bspwmrc", XDG_CONFIG_DIR / "bspwm/bspwmrc"),
    ],
)
_pkgs["gpg"] = ConfiguredPackage(
    system_packages={
        Pacman("gnupg"), Pacman("pcsclite"), Pacman("ccid")
    },
    files=[
        Config("gpg/gpg.conf", HOME / ".local/gpg/gpg.conf"),
        Config("gpg/gpg-agent.conf", HOME / ".local/gpg/gpg-agent.conf"),
        Config("gpg/scdaemon.conf", HOME / ".local/gpg/scdaemon.conf"),
        Config("gpg/environment", HOME / ".local/environment/gpg"),
        Perms(HOME / ".local/gpg", 0o700),
    ],
    after=lambda: ensure_service("pcscd.socket"),
)
_pkgs["homebin"] = ConfiguredPackage(
    files=[
        Perms(HOME / ".local/bin", 0o755),
        Config("homebin/environment", HOME / ".local/environment/homebin"),
    ]
)
_pkgs["git"] = ConfiguredPackage(
    deps={_pkgs["homebin"]},
    system_packages={
       Pacman("openssh"), Pacman("git"), Pacman("man-db")
    },
    files=[
        Config("git/gitconfig", XDG_CONFIG_DIR / "git/config"),
        Config("git/gitignore", XDG_CONFIG_DIR / "git/ignore"),
        Config("git/wrapper.sh", HOME / ".local/bin/git"),
    ],
)
_pkgs["python"] = ConfiguredPackage(
    system_packages={Pacman("python")},
    files=[Config("python/pip.conf", XDG_CONFIG_DIR / "pip/pip.conf")],
)
_pkgs["supervisord"] = ConfiguredPackage(
    deps={_pkgs["python"], _pkgs["homebin"]},
    system_packages={PythonVenv("supervisor", "supervisor")},
    files=[
        Config(PythonVenv.PATH / "supervisor/bin/supervisorctl", HOME / ".local/bin/supervisorctl"),
        Config("supervisord/supervisord.conf", XDG_CONFIG_DIR / "supervisord/supervisord.conf"),
        Perms(XDG_CONFIG_DIR / "supervisord/config.d", 0o755),
        Perms(PythonVenv.PATH / "supervisor/log", 0o755),
        Config("supervisord/supervisord.service", XDG_CONFIG_DIR / "systemd/user/supervisord.service"),
    ],
    after=lambda: ensure_service("supervisord", user=True),
)
_pkgs["dropbox"] = ConfiguredPackage(
    deps={_pkgs["supervisord"]},
    system_packages={Pacman("qt5-base"), PythonVenv("maestral", "maestral", "maestral-qt")},
    files=[
        Config("dropbox/supervisord.conf", XDG_CONFIG_DIR / "supervisord/config.d/dropbox.conf"),
        Config(PythonVenv.PATH / "maestral/bin/maestral", HOME / ".local/bin/maestral"),
    ],
    after=lambda: run("supervisorctl reload"),
)

_pkgs["docker"] = ConfiguredPackage(
    deps={_pkgs["homebin"]},
    system_packages={Pacman("docker")},
    files=[Config("docker/wrapper.sh", HOME / ".local/bin/docker")],
    after=lambda: (ensure_service("docker"), add_group("docker")),
)
_pkgs["aur"] = ConfiguredPackage(
    deps={_pkgs["homebin"], _pkgs["docker"]},
    files=[
        Config("aur/aur.py", HOME / ".local/bin/aur"),
        Perms(HOME / ".local/bin/aur", 0o744),
    ],
)
_pkgs["unclutter"] = ConfiguredPackage(
    deps={_pkgs["supervisord"]},
    system_packages={Pacman("unclutter")},
    files=[Config("unclutter/supervisord.conf", XDG_CONFIG_DIR / "supervisord/config.d/unclutter.conf")],
    after=lambda: run("supervisorctl reload"),
)
_pkgs["picom"] = ConfiguredPackage(
    deps={_pkgs["supervisord"], _pkgs["aur"]},
    system_packages={Aur("picom-tryone-git")},
    files=[
        Config("picom/supervisord.conf", XDG_CONFIG_DIR / "supervisord/config.d/compositor.conf"),
        Config("picom/picom.conf", XDG_CONFIG_DIR / "picom/picom.conf"),
    ],
    after=lambda: run("supervisorctl reload"),
)


def chsh(sh):
    if os.environ.get("SHELL") == sh:
        return
    run(f"chsh -s {sh}")

_pkgs["zsh"] = ConfiguredPackage(
    deps={},
    system_packages={
        Pacman("zsh"), Pacman("zsh-syntax-highlighting"), Pacman("zsh-completions"), Aur("aur/pkgs/cli-utils")
    },
    files=[
        Config("zsh/zshrc", HOME / ".zshrc"),
        Config("zsh/settings", XDG_CONFIG_DIR / "zsh/settings"),
        Config("zsh/environment", HOME / ".local/environment/zsh"),
    ],
    after=lambda: chsh("/bin/zsh"),
)
_pkgs["alacritty"] = ConfiguredPackage(
    deps={_pkgs["aur"]},
    system_packages={
        Pacman("alacritty"), Aur("aur/pkgs/ttf-anonymous-pro-ext"),
    },
    files=[
        Config("alacritty/alacritty.yml", XDG_CONFIG_DIR / "alacritty/alacritty.yml"),
    ],
)

def get_targets(tgt: str) -> Sequence[ConfiguredPackage]:
    targets: Sequence[ConfiguredPackage] = []
    targets.append(_pkgs.get(tgt))
    targets += targets[0].deps

    return targets


if __name__ == "__main__":
    if len(sys.argv) == 1:
        print("Pass args")
        sys.exit(1)

    targets: Sequence[ConfiguredPackage] = []
    for arg in sys.argv[1:]:
        if arg == "--dry-run":
            DRY_RUN = True
        else:
            resolved_targets = get_targets(arg)
            targets += resolved_targets

    pacman_packages = set()
    other_packages = []
    for target in targets:
        for system_pkg in target.system_packages:
            if isinstance(system_pkg, Pacman):
                pacman_packages.add(system_pkg)
            else:
                other_packages.append(system_pkg)

    Pacman.install(*pacman_packages)
    for pkg in other_packages:
        pkg.install()

    for target in targets:
        for f in target.files:
            f.create()
        if target.after and not DRY_RUN:
            target.after()
