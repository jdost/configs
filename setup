#!/usr/bin/env python3

import abc
import importlib
import os
import shlex
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Sequence, Set, Union

DRY_RUN = False
REPO_BASE = Path(__file__).resolve().parent
XDG_CONFIG_DIR = Path.home() / '.config'
HOME = Path.home()


def run(
    cmd: Union[str, Sequence[Union[Path, str]]],
    capture=False,
) -> subprocess.CompletedProcess:
    resolved_cmd = shlex.split(cmd) if isinstance(cmd, str) else cmd
    return subprocess.run(
        resolved_cmd,
        stdout=subprocess.PIPE if capture else None,
        cwd=REPO_BASE,
    )


class ConfiguredPackage:
    deps: Set["ConfiguredPackage"] = {}
    system_packages: Set["SystemPackage"] = {}
    files: Sequence["Config"] = {}

    def __init__(self, deps=set(), system_packages=set(), files=[], after=None):
        self.deps = deps
        self.system_packages = system_packages
        self.files = files
        self.after = after


class SystemPackage(abc.ABC):
    pass


class Pacman(SystemPackage):
    name: str = ""

    def __init__(self, name: str):
        self.name = name

    @staticmethod
    def list_installed() -> Set[str]:
        if not hasattr(Pacman, "_installed"):
            Pacman._installed = {
                o.split(" ")[0] for o in run("pacman -Q", capture=True).stdout.decode("utf-8").split()
            }
        return Pacman._installed

    @staticmethod
    def install(*pkgs: "Pacman") -> None:
        wanted = {pkg.name for pkg in pkgs}
        installed = Pacman.list_installed()

        to_be_installed = wanted - installed
        if not to_be_installed:
            # everything is already installed
            return

        if DRY_RUN:
            print(f"WOULD INSTALL: {', '.join(to_be_installed)}")
        else:
            run(["sudo", "pacman", "-Syu", "--needed", "-y"] + list(to_be_installed))


class Aur(SystemPackage):
    def __init__(self, *definitions):
        self.packages = definitions

    def install(self):
        to_be_installed = []
        for pkg in self.packages:
            local_pkg = Path(pkg)
            if local_pkg.exists():
                pkgbuild = local_pkg if local_pkg.is_file() else local_pkg / "PKGBUILD"
                if not pkgbuild.exists():
                    if pkg not in Pacman.list_installed():
                        to_be_installed.append(pkg)
                    continue

                for line in pkgbuild.read_text().split("\n"):
                    if line.startswith("pkgname="):
                        pkgname = line[8:].strip("'\"")
                        if pkgname not in Pacman.list_installed():
                            to_be_installed.append(pkg)
                        break
            elif pkg not in Pacman.list_installed():
                to_be_installed.append(pkg)
            else:
                continue

        if not len(to_be_installed):
            return
        elif DRY_RUN:
            print(f"$ aur install {' '.join(to_be_installed)}")
        else:
            run(["aur", "install"] + to_be_installed)


class PythonVenv(SystemPackage):
    PATH = HOME / ".local"

    def __init__(self, name: str, *pkgs: str):
        self.name = name
        self.requirements = set(pkgs)

    def install(self):
        if not (self.PATH / self.name).exists():
            if DRY_RUN:
                if not self.PATH.exists():
                    print(f"$ mkdir -p {self.PATH}")
                print(f"$ python -m venv {self.PATH / self.name}")
            else:
                if not self.PATH.exists():
                    self.PATH.mkdir(parents=True)
                run(f"python -m venv {self.PATH / self.name}")

        installed_requirements = {req.split("=")[0] for req in run(
            [self.PATH / self.name / "bin/python", "-m", "pip", "freeze"],
            capture=True,
        ).stdout.decode("utf-8").split()} if (self.PATH / self.name / "bin/python").exists() else set()
        to_be_installed = self.requirements - installed_requirements
        if to_be_installed:
            if DRY_RUN:
                print(f"$ {self.PATH / self.name}/bin/python -m pip install {' '.join(self.requirements)}")
            else:
                run(
                    [self.PATH / self.name / "bin/python", "-m", "pip", "install"]
                    + list(self.requirements)
                )


class Config:
    src: Path
    dst: Path

    @staticmethod
    def _convert_loc(a: Union[Path, str]) -> Path:
        if not isinstance(a, Path):
            a = Path(a)

        if a.is_absolute():
            return a

        return REPO_BASE / a

    def __init__(self, src: Union[Path, str], dst: Union[Path, str]):
        self.src = self._convert_loc(src)
        self.dst = self._convert_loc(dst)

    def create(self, overwrite: bool = False) -> None:
        if not self.src.exists():
            # This probably means a typo somewhere
            raise FileNotFoundError(self.src)

        if self.dst.exists():
            if self.dst.resolve() == self.src:
                # already the right symlink
                return

            if not overwrite:
                return
            else:
                self.dst.unlink()

        if not self.dst.parent.exists():
            if DRY_RUN:
                print(f"$ mkdir -p {self.dst.parent}")
            else:
                self.dst.parent.mkdir(parents=True)

        if DRY_RUN:
            print(f"$ ln -s {self.src} {self.dst}")
        else:
            try:
                self.dst.symlink_to(self.src)
            except PermissionError:
                run(f"sudo ln -s {self.src} {self.dst}")


class Perms:
    target: Path
    perms: int
    MASK=0o777

    def __init__(self, target: Path, perms: int):
        self.target = target
        self.perms = perms

    def create(self) -> None:
        if not self.target.exists():
            if DRY_RUN:
                print(f"$ mkdir -p {self.target}")
            else:
                self.target.mkdir(parents=True)

        current = self.target.stat().st_mode & Perms.MASK
        if current == self.perms:
            return

        if DRY_RUN:
            print(f"$ chmod {self.perms} {self.target}")
        else:
            self.target.chmod(self.perms)


def ensure_service(service, user=False):
    systemctl = "systemctl --user" if user else "systemctl"
    if run(f"{systemctl} status {service}", capture=True).returncode == 0:
        return

    if DRY_RUN and user:
        print(f"$ systemctl --user enable --now {service}")
    elif DRY_RUN:
        print(f"$ sudo systemctl enable --now {service}")
    elif user:
        run(f"systemctl --user enable --now {service}")
    else:
        run(f"sudo systemctl enable --now {service}")


def add_group(group):
    user = os.environ["USER"]
    groups = run(f"groups {user}", capture=True).stdout.decode("utf-8").split()
    if group in groups:
        return

    if DRY_RUN:
        print(f"$ sudo usermod -aG {group} {user}")
        print(f"$ newgrp {group}")
    else:
        run(f"sudo usermod -aG {group} {user}")
        run(f"newgrp {group}")


_pkgs = {}
_pkgs["gpg"] = ConfiguredPackage(
    system_packages={
        Pacman("gnupg"), Pacman("pcsclite"), Pacman("ccid")
    },
    files=[
        Config("gpg/gpg.conf", HOME / ".local/gpg/gpg.conf"),
        Config("gpg/gpg-agent.conf", HOME / ".local/gpg/gpg-agent.conf"),
        Config("gpg/scdaemon.conf", HOME / ".local/gpg/scdaemon.conf"),
        Config("gpg/environment", HOME / ".local/environment/gpg"),
        Config("gpg/xinitrc", XDG_CONFIG_DIR / "xorg/xinitrd.d/20-gpg"),
        Perms(HOME / ".local/gpg", 0o700),
    ],
    after=lambda: ensure_service("pcscd.socket"),
)
_pkgs["homebin"] = ConfiguredPackage(
    files=[
        Perms(HOME / ".local/bin", 0o755),
        Config("homebin/environment", HOME / ".local/environment/homebin"),
        Config("homebin/settitle.sh", HOME / ".local/bin/settitle"),
    ]
)
_pkgs["git"] = ConfiguredPackage(
    deps={_pkgs["homebin"]},
    system_packages={
       Pacman("openssh"), Pacman("git"), Pacman("man-db")
    },
    files=[
        Config("git/gitconfig", XDG_CONFIG_DIR / "git/config"),
        Config("git/gitignore", XDG_CONFIG_DIR / "git/ignore"),
        Config("git/wrapper.sh", HOME / ".local/bin/git"),
    ],
)
_pkgs["python"] = ConfiguredPackage(
    system_packages={Pacman("python")},
    files=[Config("python/pip.conf", XDG_CONFIG_DIR / "pip/pip.conf")],
)
_pkgs["dropbox"] = ConfiguredPackage(
    deps={},
    system_packages={Pacman("qt5-base"), PythonVenv("maestral", "maestral", "maestral-qt")},
    files=[
        Config("dropbox/dropbox.service", XDG_CONFIG_DIR / "systemd/user/dropbox.service"),
        Config(PythonVenv.PATH / "maestral/bin/maestral", HOME / ".local/bin/maestral"),
    ],
    after=lambda: ensure_service("dropbox", user=True),
)

_pkgs["docker"] = ConfiguredPackage(
    deps={_pkgs["homebin"]},
    system_packages={Pacman("docker")},
    files=[Config("docker/wrapper.sh", HOME / ".local/bin/docker")],
    after=lambda: (ensure_service("docker"), add_group("docker")),
)
_pkgs["aur"] = ConfiguredPackage(
    deps={_pkgs["homebin"], _pkgs["docker"]},
    files=[
        Config("aur/aur.py", HOME / ".local/bin/aur"),
        Perms(HOME / ".local/bin/aur", 0o744),
    ],
)
_pkgs["unclutter"] = ConfiguredPackage(
    deps={},
    system_packages={Pacman("unclutter")},
    files=[Config("unclutter/unclutter.service", XDG_CONFIG_DIR / "systemd/user/unclutter.service")],
    after=lambda: ensure_service("unclutter", user=True),
)
_pkgs["picom"] = ConfiguredPackage(
    deps={_pkgs["aur"]},
    system_packages={Aur("picom-tryone-git")},
    files=[
        Config("picom/compositor.service", XDG_CONFIG_DIR / "systemd/user/compositor.service"),
        Config("picom/picom.conf", XDG_CONFIG_DIR / "picom/picom.conf"),
    ],
    after=lambda: ensure_service("compositor", user=True),
)
_pkgs["deadd"] = ConfiguredPackage(
    deps={_pkgs["aur"]},
    system_packages={Aur("deadd-notification-center-bin")},
    files=[
        Config("deadd/deadd.conf", XDG_CONFIG_DIR / "deadd/deadd.conf"),
        Config("deadd/notifications.service", XDG_CONFIG_DIR / "systemd/user/notifications.service"),
    ],
    after=lambda: ensure_service("notifications", user=True),
)
_pkgs["xorg"] = ConfiguredPackage(
    system_packages={Pacman("xorg-xinit"), Pacman("xorg-server")},
    files=[
        Config("xorg/xorg.target", XDG_CONFIG_DIR / "systemd/user/xorg.target"),
        Config("xorg/xinitrc", HOME / ".xinitrc"),
        Config("xorg/xinitrc.d/01-systemd", XDG_CONFIG_DIR / "xorg/xinitrc.d/01-systemd"),
        Config("xorg/caps-ctrl-swap.xmodmap", XDG_CONFIG_DIR / "xorg/caps-ctrl-swap.xmodmap"),
        Config("xorg/xinitrc.d/10-xmodmap", XDG_CONFIG_DIR / "xorg/xinitrc.d/10-xmodmap"),
    ],
)


def chsh(sh):
    if os.environ.get("SHELL") == sh:
        return
    run(f"chsh -s {sh}")

_pkgs["zsh"] = ConfiguredPackage(
    deps={},
    system_packages={
        Pacman("zsh"), Pacman("zsh-syntax-highlighting"), Pacman("zsh-completions"), Aur("aur/pkgs/cli-utils")
    },
    files=[
        Config("zsh/zshrc", HOME / ".zshrc"),
        Config("zsh/settings", XDG_CONFIG_DIR / "zsh/settings"),
        Config("zsh/environment", HOME / ".local/environment/zsh"),
    ],
    after=lambda: chsh("/bin/zsh"),
)
_pkgs["alacritty"] = ConfiguredPackage(
    deps={_pkgs["aur"]},
    system_packages={
        Pacman("alacritty"), Aur("aur/pkgs/ttf-hack-ext")
    },
    files=[
        Config("alacritty/alacritty.yml", XDG_CONFIG_DIR / "alacritty/alacritty.yml"),
    ],
)
_pkgs["polybar"] = ConfiguredPackage(
    deps={_pkgs["aur"]},
    system_packages={Aur("polybar"), Aur("aur/pkgs/ttf-anonymous-pro-ext")},
    files=[
        Config("polybar/config", XDG_CONFIG_DIR / "polybar/config"),
        Config("polybar/modules", XDG_CONFIG_DIR / "polybar/modules"),
        Config("polybar/statusbar.service", XDG_CONFIG_DIR / "systemd/user/statusbar.service"),
    ],
    after=lambda: ensure_service("statusbar", user=True),
)
_pkgs["wallpaper"] = ConfiguredPackage(
    system_packages={
        Pacman("feh"), Pacman("curl"), Pacman("which")
    },
    files=[
        Config("wallpaper/wallpaper.sh", HOME / ".local/bin/wallpaper"),
        Config("wallpaper/wallpaper.service", XDG_CONFIG_DIR / "systemd/user/wallpaper.service"),
        Config("wallpaper/wallpaper.timer", XDG_CONFIG_DIR / "systemd/user/wallpaper.timer"),
        Config("wallpaper/xinitrc", XDG_CONFIG_DIR / "xorg/xinitrc.d/10-wallpaper"),
    ],
    after=lambda: ensure_service("wallpaper.timer", user=True),
)
_pkgs["rofi"] = ConfiguredPackage(
    system_packages={
        Pacman("rofi"), Aur("aur/pkgs/ttf-hack-ext"),
    },
    files=[
        Config("rofi/default.rasi", XDG_CONFIG_DIR / "rofi/default.rasi"),
        Config("rofi/config.rasi", XDG_CONFIG_DIR / "rofi/config.rasi"),
        Config("rofi/scripts/totp", XDG_CONFIG_DIR / "rofi/scripts/totp"),
        Config("rofi/scripts/pass", XDG_CONFIG_DIR / "rofi/scripts/pass"),
    ],
)
_pkgs["screenlock"] = ConfiguredPackage(
    system_packages={
        Pacman("mpv"), Pacman("xsecurelock"), Pacman("xss-lock"),
    },
    files=[
        Config("screenlock/screenlock.sh", HOME / ".local/bin/screenlock"),
        Config("screenlock/screenlock.service", XDG_CONFIG_DIR / "systemd/user/screenlock.service"),
        Config("screenlock/xinitrc", XDG_CONFIG_DIR / "xorg/xinitrc.d/10-screenlock"),
        Config("screenlock/saver_mpv-cinemagraph", "/usr/lib/xsecurelock/saver_mpv-cinemagraph"),
    ],
    after=lambda: ensure_service("screenlock", user=True),
)
_pkgs["sxhkd"] =  ConfiguredPackage(
    system_packages={Pacman("sxhkd")},
    files=[
        Config("sxhkd/sxhkdrc", XDG_CONFIG_DIR / "sxhkd/sxhkdrc"),
    ],
)
_pkgs["bspwm"] = ConfiguredPackage(
    deps={
        _pkgs["sxhkd"], _pkgs["deadd"], _pkgs["picom"], _pkgs["unclutter"], _pkgs["alacritty"], _pkgs["xorg"]
    },
    system_packages={ Pacman("bspwm") },
    files=[
        Config("bspwm/bspwmrc", XDG_CONFIG_DIR / "bspwm/bspwmrc"),
        Config("bspwm/polybar", XDG_CONFIG_DIR / "polybar/system"),
        Config("bspwm/xinitrc", XDG_CONFIG_DIR / "xorg/xinitrc.d/99-bspwm"),
    ],
)

def get_targets(tgt: str) -> Sequence[ConfiguredPackage]:
    targets: Sequence[ConfiguredPackage] = []
    targets.append(_pkgs.get(tgt))
    targets += targets[0].deps

    return targets


if __name__ == "__main__":
    if len(sys.argv) == 1:
        print("Pass args")
        sys.exit(1)

    targets: Sequence[ConfiguredPackage] = []
    for arg in sys.argv[1:]:
        if arg == "--dry-run":
            DRY_RUN = True
        else:
            resolved_targets = get_targets(arg)
            targets += resolved_targets

    pacman_packages = set()
    other_packages = []
    for target in targets:
        for system_pkg in target.system_packages:
            if isinstance(system_pkg, Pacman):
                pacman_packages.add(system_pkg)
            else:
                other_packages.append(system_pkg)

    Pacman.install(*pacman_packages)
    for pkg in other_packages:
        pkg.install()

    for target in targets:
        for f in target.files:
            f.create()
        if target.after and not DRY_RUN:
            target.after()
